from __future__ import annotations

from dataclasses import dataclass, field
from typing import Generic, Protocol, TypeVar, Callable, Iterable, Any
import json

Input = TypeVar("Input", contravariant=True)
Output = TypeVar("Output", covariant=True)


class CryptoModule(Protocol[Input, Output]):
    """Protocol for pipeline modules."""

    def run(self, data: Input) -> Output:
        """Run the module on the provided data."""
        ...


@dataclass
class Pipeline(Generic[Input, Output]):
    """Composable cryptographic pipeline."""

    modules: list[CryptoModule[Any, Any]] = field(default_factory=list)
    tracked_secrets: list[str] = field(default_factory=list)

    # operator overloads -------------------------------------------------
    def __rshift__(self, other: CryptoModule[Any, Any] | "Pipeline") -> "Pipeline":
        new_modules: list[CryptoModule[Any, Any]] = list(self.modules)
        if isinstance(other, Pipeline):
            new_modules.extend(other.modules)
        else:
            new_modules.append(other)
        return Pipeline(new_modules)

    # execution -----------------------------------------------------------
    def run(self, data: Any) -> Any:
        result = data
        for mod in self.modules:
            result = mod.run(result)
        return result

    # introspection -------------------------------------------------------
    def describe(self) -> list[dict[str, Any]]:
        desc: list[dict[str, Any]] = []
        for mod in self.modules:
            info: dict[str, Any] = {
                "module": mod.__class__.__name__,
            }
            if hasattr(mod, "__dict__"):
                info["params"] = {
                    k: v for k, v in vars(mod).items() if not k.startswith("_")
                }
            desc.append(info)
        if self.tracked_secrets:
            desc.append({"tracked_secrets": list(self.tracked_secrets)})
        return desc

    def track_secret(self, name: str) -> None:
        """Mark a secret to be monitored in exported models."""

        if name not in self.tracked_secrets:
            self.tracked_secrets.append(name)

    # formal verification ------------------------------------------------
    def to_proverif(self) -> str:
        """Export the pipeline as a simplistic ProVerif process."""

        lines = ["(* Generated by cryptography-suite *)", "process"]
        for sec in self.tracked_secrets:
            lines.append(f"  (* track {sec} *)")
        for mod in self.modules:
            if hasattr(mod, "to_proverif"):
                lines.append(f"  {mod.to_proverif()}")
            else:
                lines.append(f"  (* {mod.__class__.__name__} step *)")
        lines.append("  nil")
        return "\n".join(lines)

    def to_tamarin(self) -> str:
        """Export the pipeline as a simplistic Tamarin model."""

        lines = ["# Generated by cryptography-suite", "theory Pipeline" + "\n"]
        for sec in self.tracked_secrets:
            lines.append(f"# track {sec}")
        for mod in self.modules:
            if hasattr(mod, "to_tamarin"):
                lines.append(mod.to_tamarin())
            else:
                lines.append(f"# {mod.__class__.__name__} step")
        return "\n".join(lines)

    def to_json(self) -> str:
        return json.dumps(self.describe())

    @classmethod
    def from_config(cls, config: Iterable[Callable[[], CryptoModule]]) -> "Pipeline":
        modules = [factory() for factory in config]
        return cls(list(modules))

    def dry_run(self, data: Any) -> Any:
        result = data
        for mod in self.modules:
            print(f"{mod.__class__.__name__}: {result!r}")
            result = mod.run(result)
        return result


class PipelineVisualizer:
    """Simple ASCII pipeline visualizer."""

    def __init__(self, pipeline: Pipeline) -> None:
        self.pipeline = pipeline

    def render_ascii(self) -> str:
        parts = [mod.__class__.__name__ for mod in self.pipeline.modules]
        return " -> ".join(parts)
