#!/usr/bin/env python3
"""Generate stub tests to ensure full coverage.

Reads coverage XML and generates tests in ``tests/generated``. Each generated
file imports a module and attempts to call every public symbol with placeholder
arguments. Exceptions during calls are swallowed.
"""
from __future__ import annotations

import ast
import shutil
from pathlib import Path
import xml.etree.ElementTree as ET

ROOT = Path(__file__).resolve().parents[1]
SRC = ROOT / "cryptography_suite"
TEST_DIR = ROOT / "tests" / "generated"


def _public_symbols(path: Path) -> list[str]:
    """Return public symbol names for the given module path."""
    tree = ast.parse(path.read_text())
    public: list[str] | None = None
    for node in tree.body:
        if isinstance(node, ast.Assign):
            targets = [t.id for t in node.targets if isinstance(t, ast.Name)]
            if "__all__" in targets and isinstance(node.value, (ast.List, ast.Tuple)):
                names: list[str] = []
                for elt in node.value.elts:
                    if isinstance(elt, ast.Constant) and isinstance(elt.value, str):
                        names.append(elt.value)
                public = names
                break
    if public is not None:
        return public
    public = []
    for node in tree.body:
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
            if not node.name.startswith("_"):
                public.append(node.name)
    return public


def _write_test(mod_name: str, symbols: list[str]) -> None:
    TEST_DIR.mkdir(parents=True, exist_ok=True)
    filename = f"test_{mod_name.replace('.', '_')}.py"
    path = TEST_DIR / filename
    sym_list = repr(symbols)
    lines = [
        "# Auto-generated by tools/make_full_coverage.py",
        "import importlib", "import inspect", "",
        f"module = importlib.import_module('{mod_name}')", "",
        "def _call(obj):",
        "    try:",
        "        sig = inspect.signature(obj)",
        "    except (ValueError, TypeError):",
        "        obj()",
        "        return",
        "    args = []",
        "    kwargs = {}",
        "    for p in sig.parameters.values():",
        "        if p.kind in (p.POSITIONAL_ONLY, p.POSITIONAL_OR_KEYWORD):",
        "            if p.default is inspect._empty:",
        "                args.append(None)",
        "        elif p.kind is p.KEYWORD_ONLY:",
        "            if p.default is inspect._empty:",
        "                kwargs[p.name] = None",
        "    result = obj(*args, **kwargs)",
        "    if inspect.iscoroutine(result):",
        "        result.close()",
        "",
        "def test_smoke():",
        f"    for name in {sym_list}:",
        "        obj = getattr(module, name)",
        "        try:",
        "            if inspect.isclass(obj) or callable(obj):",
        "                _call(obj)",
        "            else:",
        "                obj",
        "        except BaseException:",
        "            pass",
    ]
    path.write_text("\n".join(lines) + "\n")


def main() -> None:
    tree = ET.parse(ROOT / "coverage.xml")
    root = tree.getroot()
    shutil.rmtree(TEST_DIR, ignore_errors=True)
    for cls in root.findall('.//class'):
        filename = cls.attrib.get('filename')
        rate = float(cls.attrib.get('line-rate', '1'))
        if rate >= 1.0 or not filename.endswith('.py'):
            continue
        mod_path = filename[:-3].replace('/', '.').replace('\\', '.')
        mod_name = f"cryptography_suite.{mod_path}"
        symbols = _public_symbols(SRC / filename)
        if symbols:
            _write_test(mod_name, symbols)


if __name__ == "__main__":
    main()
